# Blocos de constru√ß√£o do LangGraph

Para criar aplica√ß√µes com o LangGraph, √© essencial conhecer seus componentes principais. Vamos explorar os blocos que comp√µem uma aplica√ß√£o nesse framework.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/Building_blocks.png" alt="Building Blocks" width="70%"/>

Uma aplica√ß√£o em LangGraph parte de um **entrypoint** e, conforme a execu√ß√£o, segue para fun√ß√µes diferentes at√© alcan√ßar o `END`.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/application.png" alt="Application"/>

## 1. State

**State** (estado) √© o conceito central. Representa todas as informa√ß√µes que percorrem a aplica√ß√£o.

```python
from typing_extensions import TypedDict

class State(TypedDict):
    graph_state: str
```

O estado √© **definido pelo usu√°rio**, portanto os campos devem conter tudo que for necess√°rio para tomar decis√µes.

> üí° **Dica:** reflita com cuidado sobre quais informa√ß√µes precisam ser rastreadas entre as etapas.

## 2. Nodes

**Nodes** s√£o fun√ß√µes Python. Cada n√≥:
- Recebe o estado como entrada;  
- Executa alguma opera√ß√£o;  
- Retorna atualiza√ß√µes para o estado.

```python
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] +" I am"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] +" happy!"}

def node_3(state):
    print("---Node 3---")
    return {"graph_state": state['graph_state'] +" sad!"}
```

Por exemplo, n√≥s podem conter:
- **Chamadas a LLMs** ‚Äî gerar texto ou tomar decis√µes;  
- **Chamadas a ferramentas** ‚Äî interagir com sistemas externos;  
- **L√≥gica condicional** ‚Äî decidir o pr√≥ximo passo;  
- **Interven√ß√£o humana** ‚Äî solicitar input do usu√°rio.

> üí° **Info:** Alguns n√≥s, como `START` e `END`, s√£o fornecidos diretamente pelo LangGraph.


## 3. Edges

**Edges** conectam os n√≥s e definem os caminhos poss√≠veis:

```python
import random
from typing import Literal

def decide_mood(state) -> Literal["node_2", "node_3"]:
    
    # Often, we will use state to decide on the next node to visit
    user_input = state['graph_state'] 
    
    # Here, let's just do a 50 / 50 split between nodes 2, 3
    if random.random() < 0.5:

        # 50% of the time, we return Node 2
        return "node_2"
    
    # 50% of the time, we return Node 3
    return "node_3"
```

As arestas podem ser:
- **Diretas** ‚Äî sempre ligam o n√≥ A ao n√≥ B;  
- **Condicionais** ‚Äî escolhem o pr√≥ximo n√≥ com base no estado atual.

## 4. StateGraph

O **StateGraph** √© o cont√™iner que re√∫ne todo o workflow:

```python
from IPython.display import Image, display
from langgraph.graph import StateGraph, START, END

# Build graph
builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)

# Logic
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_mood)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

# Add
graph = builder.compile()
```

Depois podemos visualizar:
```python
# View
display(Image(graph.get_graph().draw_mermaid_png()))
```
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/basic_graph.jpeg" alt="Graph Visualization"/>

E, o mais importante, invocar:
```python
graph.invoke({"graph_state" : "Hi, this is Lance."})
```
Sa√≠da:
```
---Node 1---
---Node 3---
{'graph_state': 'Hi, this is Lance. I am sad!'}
```

## O que vem a seguir?

Na pr√≥xima se√ß√£o, vamos colocar os conceitos em pr√°tica construindo nosso primeiro grafo. Alfred passar√° a receber seus e-mails, classific√°-los e elaborar uma resposta preliminar sempre que forem leg√≠timos.
