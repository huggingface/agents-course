# O que √© o `LangGraph`?

`LangGraph` √© um framework desenvolvido pela [LangChain](https://www.langchain.com/) **para controlar o fluxo de aplica√ß√µes que integram um LLM**.

## `LangGraph` √© diferente de `LangChain`?

LangChain fornece interfaces padr√£o para interagir com modelos, fazer chamadas a ferramentas e realizar buscas.  
As classes do LangChain **podem** ser usadas no LangGraph, mas n√£o √© obrigat√≥rio.

Os pacotes s√£o distintos e funcionam isoladamente ‚Äî embora, na pr√°tica, voc√™ encontre muitos exemplos combinando ambos.

## Quando devo usar o `LangGraph`?
### Controle x liberdade

Ao projetar aplica√ß√µes de IA, existe um equil√≠brio entre **controle** e **liberdade**:

- **Liberdade** d√° espa√ßo para o LLM ser criativo e resolver problemas inesperados.  
- **Controle** garante comportamento previs√≠vel e mant√©m limites.

Code Agents, como os do *smolagents*, s√£o bastante livres: chamam v√°rias ferramentas em um passo, criam ferramentas novas etc. Por outro lado, tornam-se menos previs√≠veis do que um agente ‚Äútradicional‚Äù baseado em JSON.

`LangGraph` situa-se no extremo do **controle**. Ele brilha quando voc√™ precisa comandar a execu√ß√£o do agente.

√â especialmente √∫til para construir aplica√ß√µes que seguem etapas bem definidas, mas **sem perder o poder dos LLMs**.  
Se sua aplica√ß√£o envolve uma sequ√™ncia de passos que deve ser coordenada com decis√µes a cada jun√ß√£o, **LangGraph entrega a estrutura ideal**.

Imagine: queremos criar um assistente que responde perguntas sobre documentos.  
Antes de responder, talvez seja necess√°rio converter um gr√°fico ou tabela em texto ‚Äî dependendo do tipo de documento. Isso j√° gera um fluxo ramificado:

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/flow.png" alt="Control flow"/>

> üí° **Dica:** No lado esquerdo n√£o h√° chamadas de ferramentas (n√£o √© um agente). No lado direito ser√° preciso escrever c√≥digo para consultar o XLS (converter para pandas, manipular etc.).

Essa ramifica√ß√£o √© determin√≠stica, mas voc√™ pode criar ramifica√ß√µes condicionadas √† resposta do LLM, tornando-as n√£o determin√≠sticas.

Casos em que o LangGraph se destaca:

- **Processos de racioc√≠nio multi-etapas** que exigem controle expl√≠cito do fluxo.  
- **Aplica√ß√µes que precisam persistir estado** entre etapas.  
- **Sistemas que combinam l√≥gica determin√≠stica com IA**.  
- **Workflows com interven√ß√µes humanas** (human-in-the-loop).  
- **Arquiteturas complexas de agentes** trabalhando em conjunto.

Em resumo, se voc√™ consegue desenhar, **como humano**, um fluxo de a√ß√µes baseado na sa√≠da de cada etapa e decidir o pr√≥ximo passo, o LangGraph √© a escolha certa.

`LangGraph` √©, na minha opini√£o, o framework ag√™ntico mais pronto para produ√ß√£o atualmente.

## Como o LangGraph funciona?

No centro da solu√ß√£o, o `LangGraph` usa um grafo direcionado para definir o fluxo da aplica√ß√£o:

- **Nodes** representam etapas de processamento (chamar um LLM, usar uma ferramenta, tomar uma decis√£o).  
- **Edges** definem as transi√ß√µes poss√≠veis entre etapas.  
- **State** √© definido pelo usu√°rio e propagado entre os n√≥s; √© a base para decidir o pr√≥ximo passo.

Vamos explorar esses blocos fundamentais no pr√≥ximo cap√≠tulo!

## Qual a diferen√ßa em rela√ß√£o a Python puro?

Talvez voc√™ pense: ‚ÄúPosso escrever tudo com `if-else`, certo?‚Äù  
Tecnicamente, sim. Mas o LangGraph oferece **vantagens** para sistemas complexos:  
- Abstra√ß√µes mais f√°ceis de usar;  
- Gest√£o de estado embutida;  
- Visualiza√ß√µes, logs (traces), suporte a human-in-the-loop e mais.

Voc√™ pode criar a mesma aplica√ß√£o sem LangGraph, mas com ele o processo fica mais simples e organizado.
