<CourseFloatingBanner 
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/#fileId=https://huggingface.co/agents-course/notebooks/blob/main/unit2/smolagents/retrieval_agents.ipynb"},
]}
askForHelpUrl="http://hf.co/join/discord" />

# Construindo sistemas Agentic RAG

> [!TIP]
> Todo o c√≥digo desta se√ß√£o est√° dispon√≠vel <a href="https://huggingface.co/agents-course/notebooks/blob/main/unit2/smolagents/retrieval_agents.ipynb" target="_blank">neste notebook</a>, execut√°vel no Google Colab.

Retrieval-Augmented Generation (RAG) combina a capacidade de buscar dados com a de gerar texto contextualizado. A consulta do usu√°rio vai para um mecanismo de busca, os resultados s√£o repassados ao modelo junto com a pergunta, e o modelo responde com base nesse contexto.

Agentic RAG leva esse conceito al√©m, **combinando agentes aut√¥nomos e recupera√ß√£o din√¢mica de conhecimento**. Em vez de um √∫nico passo de busca, o agente pode formular consultas, criticar resultados, realizar m√∫ltiplas buscas e produzir respostas sob medida.

Sistemas RAG tradicionais costumam:
- Fazer apenas uma busca;  
- Depender fortemente da similaridade sem√¢ntica direta com a pergunta, podendo ignorar conte√∫do relevante.

O Agentic RAG contorna essas limita√ß√µes permitindo que o agente:
- Formule consultas mais adequadas;  
- Avalie resultados;  
- Conduza buscas iterativas;  
- Gere respostas mais precisas.

## Busca b√°sica com DuckDuckGo

Vamos criar um agente simples que busque na web com DuckDuckGo, re√∫na os resultados e sintetize uma resposta. No cen√°rio do Alfred:

- Procurar tend√™ncias atuais de festas de super-her√≥is;  
- Refinar os resultados para incluir elementos luxuosos;  
- Sintetizar tudo em um plano completo.

```python
from smolagents import CodeAgent, DuckDuckGoSearchTool, InferenceClientModel

search_tool = DuckDuckGoSearchTool()
model = InferenceClientModel()

agent = CodeAgent(
    model=model,
    tools=[search_tool],
)

response = agent.run(
    "Search for luxury superhero-themed party ideas, including decorations, entertainment, and catering."
)
print(response)
```

O fluxo √©:
1. **Analisar o pedido** ‚Äî identificar palavra‚Äëchave, foco em luxo etc.  
2. **Buscar na web** ‚Äî usar DuckDuckGo para trazer informa√ß√µes atualizadas.  
3. **Sintetizar** ‚Äî combinar os resultados em um plano com decora√ß√£o, entretenimento e buffet.  
4. **Guardar para reutiliza√ß√£o** ‚Äî manter em mem√≥ria para consultas futuras.

## Ferramenta com base de conhecimento personalizada

Para tarefas especializadas, uma base pr√≥pria √© muito √∫til. Vamos criar uma ferramenta que consulta um banco vetorial com ideias de festa. Utilizaremos:

- Embeddings (armazenados em um vector store);  
- `BM25Retriever` para busca sem√¢ntica simples;  
- `RecursiveCharacterTextSplitter` para dividir documentos em blocos menores.

```python
from langchain.docstore.document import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from smolagents import Tool
from langchain_community.retrievers import BM25Retriever
from smolagents import CodeAgent, InferenceClientModel

class PartyPlanningRetrieverTool(Tool):
    name = "party_planning_retriever"
    description = "Busca ideias de festa para a Mans√£o Wayne."
    inputs = {
        "query": {
            "type": "string",
            "description": "Consulta relacionada a planejamento de festa ou her√≥is.",
        }
    }
    output_type = "string"

    def __init__(self, docs, **kwargs):
        super().__init__(**kwargs)
        self.retriever = BM25Retriever.from_documents(docs, k=5)

    def forward(self, query: str) -> str:
        assert isinstance(query, str), "Sua busca deve ser uma string"
        docs = self.retriever.invoke(query)
        return "\nRetrieved ideas:\n" + "".join(
            f"\n\n===== Idea {i} =====\n{doc.page_content}"
            for i, doc in enumerate(docs)
        )

party_ideas = [
    {"text": "Baile mascarado com her√≥is cl√°ssicos e decora√ß√£o em dourado.", "source": "Party Ideas 1"},
    {"text": "DJ profissional com trilha sonora de Batman e Mulher-Maravilha.", "source": "Entertainment Ideas"},
    {"text": "Buffet com pratos tem√°ticos, como Smoothie do Hulk e Bife do Homem de Ferro.", "source": "Catering Ideas"},
    {"text": "Logotipos e proje√ß√µes de cidades de her√≥is pela mans√£o.", "source": "Decoration Ideas"},
    {"text": "Experi√™ncias de realidade virtual com desafios heroicos.", "source": "Entertainment Ideas"}
]

source_docs = [
    Document(page_content=doc["text"], metadata={"source": doc["source"]})
    for doc in party_ideas
]

text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,
    chunk_overlap=50,
    add_start_index=True,
    strip_whitespace=True,
    separators=["\n\n", "\n", ".", " ", ""],
)
docs_processed = text_splitter.split_documents(source_docs)

party_planning_retriever = PartyPlanningRetrieverTool(docs_processed)
agent = CodeAgent(tools=[party_planning_retriever], model=InferenceClientModel())

response = agent.run(
    "Find ideas for a luxury superhero-themed party, including entertainment, catering, and decoration options."
)

print(response)
```

Esse agente:
1. Consulta a base personalizada;  
2. Busca e mistura insights relevantes;  
3. Mant√©m contexto em mem√≥ria para conversas posteriores.

## Estrat√©gias avan√ßadas

Ao construir Agentic RAGs, podemos aplicar t√©cnicas como:

1. **Reformula√ß√£o de consultas** ‚Äî o agente adapta a pergunta para encontrar documentos mais relevantes.  
2. **Decomposi√ß√£o** ‚Äî divide perguntas complexas em v√°rias consultas menores.  
3. **Expans√£o** ‚Äî cria vers√µes alternativas da pergunta para ampliar a busca.  
4. **Reranking** ‚Äî usa modelos de classifica√ß√£o (cross-encoders) para refinar os resultados.  
5. **Busca multi-etapas** ‚Äî novas buscas s√£o guiadas pelos resultados iniciais.  
6. **Integra√ß√£o de fontes** ‚Äî combina web search com bases locais.  
7. **Valida√ß√£o** ‚Äî analisa a relev√¢ncia antes de usar as informa√ß√µes.

A constru√ß√£o de um Agentic RAG eficiente requer:

- Escolher a ferramenta certa para cada tipo de consulta;  
- Usar mem√≥ria para manter o hist√≥rico;  
- Ter planos de fallback;  
- Validar as respostas antes de apresent√°-las.

## Recursos

- [Agentic RAG: turbocharge your RAG with query reformulation and self-query! üöÄ](https://huggingface.co/learn/cookbook/agent_rag) ‚Äî receita completa usando smolagents. 
