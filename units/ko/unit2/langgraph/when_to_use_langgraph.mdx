# `LangGraph`란 무엇인가요? [[what-is-langgraph]]

`LangGraph`는 [LangChain](https://www.langchain.com/)에서 개발한 프레임워크로, **LLM을 통합한 어플리케이션의 제어 흐름을 관리**하기 위해 만들어졌습니다.

## `LangGraph`는 `LangChain`와 어떻게 다른가요? [[is-langgraph-different-from-langchain]]

LangChain은 모델 및 기타 구성 요소와 상호작용하기 위한 표준 인터페이스를 제공하며, 검색, LLM 호출, 툴 호출에 유용합니다.
LangChain의 클래스들은 LangGraph에서 사용될 수 있지만, 반드시 사용해야 하는 것은 아닙니다.

두 패키지는 서로 다른 패키지이며, 각각 독립적으로 사용할 수 있지만, 실제로 온라인에서 찾을 수 있는 대부분의 예제에서는 두 패키지를 함께 사용하는 경우가 많습니다.

## 언제 `LangGraph`를 사용해야 할까요? [[when-should-i-use-langgraph]]
### 제어 vs 자유 [[control-vs-freedom]]

AI 어플리케이션을 설계할 때, **제어**와 **자유** 사이의 트레이드오프를 고려해야합니다:

- **자유**는 LLM이 더 많은 창의성을 발휘하고 예상치 못한 문제를 해결할 수 있도록 합니다.
- **제어**는 예측 가능한 동작을 보장하고 안전 장치를 유지할 수 있습니다.

*smolagents*의 코드 에이전트는 매우 자유롭습니다. 하나의 액션 단계에서 여러 도구를 호출하거나, 자체적으로 도구를 만들기도 합니다. 하지만 이런 동작은 JSON 기반 에이전트보다 예측하기 어렵고 제어하기 어렵게 만듭니다!

`LangGraph`는 스펙트럼의 반대편에 있으며, 에이전트 실행에 **"제어"**가 필요할 때 빛납니다.

LangGraph는 특히 **어플리케이션에 대한 제어**가 필요할 때 가치가 있습니다. 예측 가능한 프로세스를 따르면서도 LLM의 힘을 활용할 수 있도록 돕는 도구를 제공합니다.

간단히 말하면, 어플리케이션이 특정 방식으로 구성된 일련의 단계를 거쳐야하고, 각 분기점에서 의사결정이 내려져야 한다면, **LangGraph가 그 필요한 구조를 제공해줍니다**.

예를 들어, 문서에 대한 질문에 답할 수 있는 LLM 어시스턴트를 구축하고 싶다고 가정해봅시다.

LLM이 텍스트를 가장 잘 이해하기 때문에, 질문에 답하기 전에 복잡한 형태들(차트, 표)을 텍스트로 변환해야 합니다. 하지만 그 선택은 문서의 유형에 따라 달라집니다!

이러한 분기 흐름은 아래와 같이 표현할 수 있습니다:

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/flow.png" alt="Control flow"/>

> 💡 **팁:** 왼쪽 부분은 도구 호출이 없기 때문에 에이전트가 아닙니다. 그러나 오른쪽 부분은 엑셀 파일을 쿼리하기 위해 코드를 작성해야 하므로 에이전트가 필요합니다.(예: pandas로 변환하고 조작).

이 분기는 결정적이지만, LLM 출력에 따라 조건이 정해지는 비결정적 분기도 설계할 수 있습니다.

LangGraph가 유용한 경우:

- **명시적인 흐름 제어가 필요한 다단계 추론 프로세스**
- **단계 간 상태 지속이 필요한 어플리케이션**
- **결정론적 로직과 AI 기능을 결합하는 시스템**
- **사람의 개입이 필요한 워크플로우**
- **여러 구성 요소가 함께 작동하는 복잡한 에이전트 아키텍처**

요약하자면, 최대한 **사람이 직접** 각 단계의 출력에 따라 실행할 다음 단계를 설계해야 하는 경우, LangGraph가 가장 적절합니다!

`LangGraph`는 제 생각에 시장에서 가장 프로덕션 준비가 잘 된 에이전트 프레임워크입니다.

## LangGraph는 어떻게 작동하나요? [[how-does-langgraph-work]]

`LangGraph`는 어플리케이션의 흐름을 정의하기 위해 방향성 그래프 구조를 사용합니다:

- **노드(Node)**는 각 처리 단계를 나타냅니다(LLM 호출, 도구 사용, 의사결정 등).
- **엣지(Edge)**는 단계 간 가능한 전환을 정의합니다.
- **상태(State)**는 사용자가 정의하고 유지하며 실행 중 노드 간에 전달됩니다. 다음에 어떤 노드를 실행할지 결정할 때, 현재 상태가 기준입니다.

이러한 기본 구성 요소들은 다음 장에서 더 자세히 살펴보겠습니다!

## 일반 파이썬과 어떻게 다른가요? 왜 LangGraph가 필요한가요? [[how-is-it-different-from-regular-python-why-do-i-need-langgraph]]

"그냥 일반 파이썬 문법으로 if-else 문 쓰면 되지 않나요?"라고 궁금해할 수 있습니다.

기술적으로는 가능하지만, LangGraph는 복잡한 시스템 구축을 위해 일반 파이썬보다 **여러가지 장점**을 제공합니다. LangGraph 없이도 동일한 어플리케이션을 구축할 수 있지만, LangGraph는 더 쉽게 개발할 수 있는 도구와 추상화를 제공합니다.

예: 상태 관리, 시각화, 로깅(트레이스), 내장형 사용자 개입 처리 기능 등.
