# Les composants de base de LangGraph

Pour cr√©er des applications avec LangGraph, vous devez comprendre ses composants principaux. Explorons les blocs fondamentaux qui constituent une application LangGraph.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/Building_blocks.png" alt="Building Blocks" width="70%"/>

Une application dans LangGraph commence √† partir d'un **point d'entr√©e**, et selon l'ex√©cution, le flux peut aller vers une fonction ou une autre jusqu'√† ce qu'il atteigne la FIN.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/application.png" alt="Application"/>

## 1. √âtat

L'**√©tat** est le concept central dans LangGraph. Il repr√©sente toutes les informations qui circulent √† travers votre application.

```python
from typing_extensions import TypedDict

class State(TypedDict):
    graph_state: str
```

L'√©tat est **d√©fini par l'utilisateur**, donc les champs doivent √™tre soigneusement con√ßus pour contenir toutes les donn√©es n√©cessaires au processus de prise de d√©cision !

> üí° **Astuce :** R√©fl√©chissez soigneusement aux informations que votre application doit suivre entre les √©tapes.

## 2. N≈ìuds

Les **n≈ìuds** sont des fonctions Python. Chaque n≈ìud :
- Prend l'√©tat en entr√©e
- Effectue une op√©ration
- Retourne des mises √† jour de l'√©tat

```python
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] +" I am"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] +" happy!"}

def node_3(state):
    print("---Node 3---")
    return {"graph_state": state['graph_state'] +" sad!"}
```

Par exemple, les n≈ìuds peuvent contenir :
- **Appels de LLM** : G√©n√©rer du texte ou prendre des d√©cisions
- **Appels d'outils** : Interagir avec des syst√®mes externes
- **Logique conditionnelle** : D√©terminer les prochaines √©tapes
- **Intervention humaine** : Obtenir des contributions des utilisateurs

> üí° **Info :** Certains n≈ìuds n√©cessaires pour l'ensemble du *workflow* comme *START* et *END* existent directement dans *LangGraph*.

## 3. Ar√™tes

Les **ar√™tes** connectent les n≈ìuds et d√©finissent les chemins possibles √† travers votre graphe :

```python
import random
from typing import Literal

def decide_mood(state) -> Literal["node_2", "node_3"]:
    
    # Souvent, nous utiliserons l'√©tat pour d√©cider du prochain n≈ìud √† visiter
    user_input = state['graph_state'] 
    
    # Ici, faisons juste une r√©partition 50/50 entre les n≈ìuds 2, 3
    if random.random() < 0.5:

        # 50% du temps, nous retournons Node 2
        return "node_2"
    
    # 50% du temps, nous retournons Node 3
    return "node_3"
```

Les ar√™tes peuvent √™tre :
- **Directes** : Toujours aller du n≈ìud A au n≈ìud B
- **Conditionnelles** : Choisir le prochain n≈ìud bas√© sur l'√©tat actuel

## 4. StateGraph

Le **StateGraph** est le conteneur qui d√©tient l'ensemble du *workflow* de votre agent :

```python
from IPython.display import Image, display
from langgraph.graph import StateGraph, START, END

# Construire le graphe
builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)

# Logique
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_mood)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

# Ajouter
graph = builder.compile()
```

Qui peut ensuite √™tre visualis√© !

```python
# Visualiser
display(Image(graph.get_graph().draw_mermaid_png()))
```

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/basic_graph.jpeg" alt="Graph Visualization"/>

Mais plus important encore, l'invocation :

```python
graph.invoke({"graph_state" : "Hi, this is Lance."})
```

ressort :

```
---Node 1---
---Node 3---
{'graph_state': 'Hi, this is Lance. I am sad!'}
```

## Et maintenant ?

Dans la prochaine section, nous mettrons ces concepts en pratique en construisant notre premier graphe. Ce graphe permet √† Alfred de prendre vos emails, les classifier, et r√©diger une r√©ponse pr√©liminaire s'ils sont authentiques.