# Qu'est-ce que LangGraph ?

`LangGraph` est un *framework* d√©velopp√© par [LangChain](https://www.langchain.com/) **pour g√©rer le flux de contr√¥le des applications qui int√®grent un LLM**.

## `LangGraph` est-il diff√©rent de `LangChain` ?

LangChain fournit une interface standard pour interagir avec les mod√®les et autres composants, utile pour la r√©cup√©ration, les appels de LLM et les appels d'outils.
Les classes de LangChain peuvent √™tre utilis√©es dans LangGraph, mais ne DOIVENT PAS n√©cessairement √™tre utilis√©es.

Les *packages* sont diff√©rents et peuvent √™tre utilis√©s de mani√®re isol√©e, mais, au final, toutes les ressources que vous trouverez en ligne utilisent les deux *packages* main dans la main.

## Quand dois-je utiliser `LangGraph` ?
### Contr√¥le vs. libert√©

Lors de la conception d'applications IA, vous faites face √† un compromis fondamental entre **contr√¥le** et **libert√©** :

- La **libert√©** donne √† votre LLM plus d'espace pour √™tre cr√©atif et s'attaquer √† des probl√®mes inattendus.
- Le **contr√¥le** vous permet d'assurer un comportement pr√©visible et de maintenir des garde-fous.

Les agents √† code, comme ceux que vous pouvez rencontrer dans *smolagents*, sont tr√®s libres. Ils peuvent appeler plusieurs outils en une seule √©tape d'action, cr√©er leurs propres outils, etc. Cependant, ce comportement peut les rendre moins pr√©visibles et moins contr√¥lables qu'un agent standard travaillant avec un *JSON* !

`LangGraph` est √† l'autre extr√©mit√© du spectre, il brille lorsque vous avez besoin de **contr√¥le** sur l'ex√©cution de votre agent. Il vous donne les outils pour cr√©er une application qui suit un processus pr√©visible tout en exploitant toujours la puissance des LLM.

En termes simples, si votre application implique une s√©rie d'√©tapes qui doivent √™tre orchestr√©es d'une mani√®re sp√©cifique, avec des d√©cisions prises √† chaque point de jonction, **LangGraph fournit la structure dont vous avez besoin**.

√Ä titre d'exemple, disons que nous voulons cr√©er un assistant LLM qui peut r√©pondre √† quelques questions sur certains documents.

Comme les LLM comprennent mieux le texte, avant de pouvoir r√©pondre √† la question, vous devrez convertir d'autres modalit√©s complexes (graphiques, tableaux) en texte. Cependant, ce choix d√©pend du type de document que vous avez !

C'est un embranchement que j'ai choisi de repr√©senter comme suit :

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/flow.png" alt="Control flow"/>

> üí° **Astuce :** La partie gauche n'est pas un agent, car ici aucun appel d'outil n'est impliqu√©. Mais la partie droite devra √©crire du code pour interroger le *xls* (convertir en *pandas* et le manipuler).

Bien que cet embranchement soit d√©terministe, vous pouvez √©galement concevoir un embranchement conditionn√© par la sortie d'un LLM, les rendant ind√©terministes.

Les sc√©narios cl√©s o√π LangGraph excelle incluent :

- **Le processus de raisonnement en plusieurs √©tapes** qui n√©cessitent un contr√¥le explicite sur le flux
- **Des applications n√©cessitant la persistance de l'√©tat** entre les √©tapes
- **Des syst√®mes qui combinent la logique d√©terministe avec les capacit√©s d'une IA**
- ***Des workflows* qui n√©cessitent des interventions *human-in-the-loop***
- **Des architectures d'agents complexes** avec plusieurs composants travaillant ensemble

En substance, chaque fois que cela est possible, en tant qu'√™tre humain, concevez un flux d'actions bas√© sur les r√©sultats de chaque action, et d√©cidez de ce qu'il faut ex√©cuter ensuite en cons√©quence. Dans ce cas, LangGraph est le bon *framework* pour vous !

`LangGraph` est, √† mon avis, le *framework* d'agents le plus pr√™t pour la production sur le march√©.

## Comment fonctionne LangGraph ?

Au c≈ìur de `LangGraph` se trouve une structure de graphe dirig√© pour d√©finir le flux de votre application :

- **Les n≈ìuds** repr√©sentent des √©tapes de traitement individuelles (comme appeler un LLM, utiliser un outil, ou prendre une d√©cision).
- **Les ar√™tes** d√©finissent les transitions possibles entre les √©tapes.
- **L'√©tat** est d√©fini par l'utilisateur et maintenu et transmis entre les n≈ìuds pendant l'ex√©cution. Lors de la d√©cision du prochain n≈ìud √† cibler, c'est l'√©tat actuel que nous regardons.

Nous explorerons ces blocs fondamentaux plus en d√©tail dans le prochain chapitre !

## En quoi est-ce diff√©rent du Python standard ? Pourquoi ai-je besoin de LangGraph ?

Vous pourriez vous demander : ¬´ Je pourrais juste √©crire du code Python standard avec des instructions *if-else* pour g√©rer tous ces flux, non ? ¬ª

Bien que techniquement vrai, LangGraph offre **certains avantages** par rapport au Python standard pour cr√©er des syst√®mes complexes. Vous pourriez cr√©er la m√™me application sans LangGraph, mais il construit des outils et des abstractions plus faciles pour vous.

Il inclut des √©tats, une visualisation, une journalisation (traces), de l'*human-in-the-loop* int√©gr√©, et plus encore.