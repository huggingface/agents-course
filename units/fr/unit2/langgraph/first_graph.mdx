# Construire votre premier LangGraph

Maintenant que nous comprenons les composants de base, mettons-les en pratique en construisant notre premier graphe fonctionnel. Nous impl√©menterons le syst√®me de traitement des emails re√ßus par Alfred, o√π il doit :

1. Lire les emails entrants
2. Les classifier comme spam ou l√©gitimes
3. R√©diger une r√©ponse pr√©liminaire pour les emails l√©gitimes
4. Envoyer les informations √† M. Wayne quand c'est l√©gitime (affichage seulement)

Cet exemple d√©montre comment structurer un *workflow* avec LangGraph qui implique une prise de d√©cision bas√©e sur LLM. Bien que cela ne puisse pas √™tre consid√©r√© comme un agent car aucun outil n'est impliqu√©, cette section se concentre plus sur l'apprentissage du *framework* LangGraph que sur les agents.

> [!TIP]
> Vous pouvez suivre le code dans <a href="https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/langgraph/mail_sorting.ipynb" target="_blank">ce <i>notebook</i></a> que vous pouvez ex√©cuter avec Google Colab.

## Notre *workflow*

Voici le *workflow* que nous allons construire :

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/first_graph.png" alt="First LangGraph"/>

## Configuration de notre environnement

Tout d'abord, installons les *packages* requis :

```python
%pip install langgraph langchain_openai
```

Ensuite, importons les modules n√©cessaires :

```python
import os
from typing import TypedDict, List, Dict, Any, Optional
from langgraph.graph import StateGraph, START, END
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
```

## √âtape 1 : D√©finir notre √©tat

D√©finissons quelles informations Alfred doit suivre pendant le *workflow* de traitement des emails :

```python
class EmailState(TypedDict):
    # L'email en cours de traitement
    email: Dict[str, Any]  # Contient sujet, exp√©diteur, corps, etc.

    # Cat√©gorie de l'email (enqu√™te, plainte, etc.)
    email_category: Optional[str]

    # Raison pourquoi l'email a √©t√© marqu√© comme spam
    spam_reason: Optional[str]

    # Analyse et d√©cisions
    is_spam: Optional[bool]
    
    # G√©n√©ration de r√©ponse
    email_draft: Optional[str]
    
    # M√©tadonn√©es de traitement
    messages: List[Dict[str, Any]]  # Suivre la conversation avec le LLM pour l'analyse
```

> üí° **Astuce :** Rendez votre √©tat suffisamment complet pour suivre toutes les informations importantes, mais √©vitez de l'encombrer avec des d√©tails inutiles.

## √âtape 2 : D√©finir nos n≈ìuds

Maintenant, cr√©ons les fonctions de traitement qui formeront nos n≈ìuds :

```python
# Initialiser notre LLM
model = ChatOpenAI(temperature=0)

def read_email(state: EmailState):
    """Alfred lit et enregistre l'email entrant"""
    email = state["email"]
    
    # Ici nous pourrions faire un pr√©traitement initial
    print(f"Alfred traite un email de {email['sender']} avec le sujet : {email['subject']}")
    
    # Aucun changement d'√©tat n√©cessaire ici
    return {}

def classify_email(state: EmailState):
    """Alfred utilise un LLM pour d√©terminer si l'email est spam ou l√©gitime"""
    email = state["email"]
    
    # Pr√©parer notre prompt pour le LLM
    prompt = f"""
    En tant qu'Alfred le majordome, analysez cet email et d√©terminez s'il s'agit de spam ou s'il est l√©gitime.
    
    email :
    De : {email['sender']}
    Sujet : {email['subject']}
    Corps : {email['body']}
    
    Premi√®rement, d√©termine si cet email est du spam. S'il s'agit de spam, explique pourquoi.
    S'il est l√©gitime, cat√©gorise-le (enqu√™te, plainte, remerciement, etc.).
    """
    
    # Appeler le LLM
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # Logique simple pour analyser la r√©ponse (dans une vraie app, vous voudriez un parsing plus robuste)
    response_text = response.content.lower()
    is_spam = "spam" in response_text and "not spam" not in response_text
    
    # Extraire une raison si c'est du spam
    spam_reason = None
    if is_spam and "reason:" in response_text:
        spam_reason = response_text.split("reason:")[1].strip()
    
    # D√©terminer la cat√©gorie si l√©gitime
    email_category = None
    if not is_spam:
        categories = ["inquiry", "complaint", "thank you", "request", "information"]
        for category in categories:
            if category in response_text:
                email_category = category
                break
    
    # Mettre √† jour les messages pour le suivi
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
    # Retourner les mises √† jour d'√©tat
    return {
        "is_spam": is_spam,
        "spam_reason": spam_reason,
        "email_category": email_category,
        "messages": new_messages
    }

def handle_spam(state: EmailState):
    """Alfred rejette l'email spam avec une note explicative"""
    print(f"Alfred a marqu√© l'email comme spam. Raison : {state['spam_reason']}")
    print("L'email a √©t√© d√©plac√© dans le dossier spam.")
    
    # Nous avons fini de traiter cet email
    return {}

def draft_response(state: EmailState):
    """Alfred r√©dige une r√©ponse pr√©liminaire pour les emails l√©gitimes"""
    email = state["email"]
    category = state["email_category"] or "general"
    
    # Pr√©parer notre prompt pour le LLM
    prompt = f"""
    En tant qu'Alfred le majordome, r√©dige une r√©ponse pr√©liminaire polie √† cet email.
    
    email :
    De : {email['sender']}
    Sujet : {email['subject']}
    Corps : {email['body']}
    
    Cet email a √©t√© cat√©goris√© comme : {category}
    
    R√©dige une r√©ponse br√®ve et professionnelle que M. Hugg peut r√©viser et personnaliser avant l'envoi.
    """
    
    # Appeler le LLM
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # Mettre √† jour les messages pour le suivi
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
    # Retourner les mises √† jour d'√©tat
    return {
        "email_draft": response.content,
        "messages": new_messages
    }

def notify_mr_hugg(state: EmailState):
    """Alfred informe M. Hugg de l'email et pr√©sente le brouillon de r√©ponse"""
    email = state["email"]
    
    print("\n" + "="*50)
    print(f"Monsieur, vous avez re√ßu un email de {email['sender']}.")
    print(f"Sujet : {email['subject']}")
    print(f"Cat√©gorie : {state['email_category']}")
    print("\nJ'ai pr√©par√© un brouillon de r√©ponse pour votre r√©vision :")
    print("-"*50)
    print(state["email_draft"])
    print("="*50 + "\n")
    
    # Nous avons fini de traiter cet email
    return {}
```

## √âtape 3 : D√©finir notre logique de routage

Nous avons besoin d'une fonction pour d√©terminer quel chemin prendre apr√®s la classification :

```python
def route_email(state: EmailState) -> str:
    """D√©terminer la prochaine √©tape bas√©e sur la classification en spam"""
    if state["is_spam"]:
        return "spam"
    else:
        return "legitimate"
```

> üí° **Note :** Cette fonction de routage est appel√©e par LangGraph pour d√©terminer quelle ar√™te suivre apr√®s le n≈ìud de classification. La valeur de retour doit correspondre √† l'une des cl√©s dans notre mappage d'ar√™tes conditionnelles.

## √âtape 4 : Cr√©er le *StateGraph* et d√©finir les ar√™tes

Maintenant nous connectons tout ensemble :

```python
# Cr√©er le graphe
email_graph = StateGraph(EmailState)

# Ajouter les n≈ìuds
email_graph.add_node("read_email", read_email)
email_graph.add_node("classify_email", classify_email)
email_graph.add_node("handle_spam", handle_spam)
email_graph.add_node("draft_response", draft_response)
email_graph.add_node("notify_mr_hugg", notify_mr_hugg)

# Commencer les ar√™tes
email_graph.add_edge(START, "read_email")
# Ajouter les ar√™tes - d√©finir le flux
email_graph.add_edge("read_email", "classify_email")

# Ajouter l'embranchement conditionnel depuis classify_email
email_graph.add_conditional_edges(
    "classify_email",
    route_email,
    {
        "spam": "handle_spam",
        "legitimate": "draft_response"
    }
)

# Ajouter les ar√™tes finales
email_graph.add_edge("handle_spam", END)
email_graph.add_edge("draft_response", "notify_mr_hugg")
email_graph.add_edge("notify_mr_hugg", END)

# Compiler le graphe
compiled_graph = email_graph.compile()
```

Remarquez comment nous utilisons le n≈ìud sp√©cial `END` fourni par LangGraph. Cela indique les √©tats terminaux o√π le *workflow* se termine.

## √âtape 5 : Ex√©cuter l'application

Testons notre graphe avec un email l√©gitime et un email spam :

```python
# Exemple d'email l√©gitime
legitimate_email = {
    "sender": "john.smith@example.com",
    "subject": "Question sur vos services",
    "body": "Cher M. Hugg, J'ai √©t√© r√©f√©r√© √† vous par un coll√®gue et je suis int√©ress√© √† en savoir plus sur vos services de conseil. Pourrions-nous programmer un appel la semaine prochaine ? Meilleures salutations, John Smith"
}

# Exemple d'email spam
spam_email = {
    "sender": "winner@lottery-intl.com",
    "subject": "VOUS AVEZ GAGN√â 5 000 000 $ !!!",
    "body": "F√âLICITATIONS ! Vous avez √©t√© s√©lectionn√© comme gagnant de notre loterie internationale ! Pour r√©clamer votre prix de 5 000 000 $, veuillez nous envoyer vos coordonn√©es bancaires et des frais de traitement de 100 $."
}

# Traiter l'email l√©gitime
print("\nTraitement de l'email l√©gitime...")
legitimate_result = compiled_graph.invoke({
    "email": legitimate_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "email_draft": None,
    "messages": []
})

# Traiter l'email spam
print("\nTraitement de l'email spam...")
spam_result = compiled_graph.invoke({
    "email": spam_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "email_draft": None,
    "messages": []
})
```

## √âtape 6 : Inspecter notre agent trieur d'email avec *Langfuse* üì°

Alors qu'Alfred peaufine l'agent trieur d'email, il se lasse de d√©boguer ses ex√©cutions. Les agents, par nature, sont impr√©visibles et difficiles √† inspecter. Mais comme il vise √† construire l'agent de d√©tection de spam ultime et √† le d√©ployer en production, il a besoin d'une tra√ßabilit√© robuste pour le *monitoring* et l'analyse futurs.

Pour cela, Alfred peut utiliser un outil d'observabilit√© comme [Langfuse](https://langfuse.com/) pour tracer et monitorer l'agent.

Premi√®rement, nous installons Langfuse avec pip :
```python
%pip install -q langfuse
```

Deuxi√®mement, nous installons LangChain avec pip (LangChain est requis car nous utilisons LangFuse) :
```python
%pip install langchain
```

Ensuite, nous ajoutons les cl√©s API LangFuse et l'adresse de l'h√¥te comme variables d'environnement. Vous pouvez obtenir vos identifiants LangFuse en vous inscrivant sur [LangFuse Cloud](https://cloud.langfuse.com) ou en [auto-h√©bergeant LangFuse](https://langfuse.com/self-hosting).

```python
import os
 
# Obtenez les cl√©s pour votre projet depuis la page des param√®tres du projet : https://cloud.langfuse.com
os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # üá™üá∫ r√©gion EU
# os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # üá∫üá∏ r√©gion US
```

Ensuite, nous configurons le [LangFuse `callback_handler`](https://langfuse.com/docs/integrations/langchain/tracing#add-langfuse-to-your-langchain-application) et instrumentons l'agent en ajoutant le `langfuse_callback` √† l'invocation du graphe : `config={"callbacks": [langfuse_handler]}`.

```python   
from langfuse.langchain import CallbackHandler

# Initialiser le CallbackHandler Langfuse pour LangGraph/Langchain (tra√ßage)
langfuse_handler = CallbackHandler()

# Traiter l'email l√©gitime
legitimate_result = compiled_graph.invoke(
    input={"email": legitimate_email, "is_spam": None, "spam_reason": None, "email_category": None, "draft_response": None, "messages": []},
    config={"callbacks": [langfuse_handler]}
)
```

Alfred est maintenant connect√© üîå ! Les ex√©cutions de LangGraph sont enregistr√©es dans LangFuse, lui donnant une visibilit√© compl√®te sur le comportement de l'agent. Avec cette configuration, il est pr√™t √† revisiter les ex√©cutions pr√©c√©dentes et √† affiner encore plus son agent de tri de courrier.

![Example trace in Langfuse](https://langfuse.com/images/cookbook/huggingface-agent-course/langgraph-trace-legit.png)

_[Lien public vers la trace avec l'email l√©gitime](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/f5d6d72e-20af-4357-b232-af44c3728a7b?timestamp=2025-03-17T10%3A13%3A28.413Z&observation=6997ba69-043f-4f77-9445-700a033afba1)_

## Visualiser notre graphe

LangGraph nous permet de visualiser notre *workflow* pour mieux comprendre et d√©boguer sa structure :

```python
compiled_graph.get_graph().draw_mermaid_png()
```
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/mail_flow.png" alt="Mail LangGraph"/>

Cela produit une repr√©sentation visuelle montrant comment nos n≈ìuds sont connect√©s et les chemins conditionnels qui peuvent √™tre pris.

## Ce que nous avons construit

Nous avons cr√©√© un *workflow* complet de traitement des emails qui :

1. Prend un email entrant
2. Utilise un LLM pour le classifier comme spam ou l√©gitime
3. G√®re le spam en le rejetant
4. Pour les emails l√©gitimes, r√©dige une r√©ponse et informe M. Hugg

Cela d√©montre la puissance de LangGraph pour orchestrer des *workflows* complexes avec des LLM tout en maintenant un flux clair et structur√©.

## Points cl√©s √† retenir

- **Gestion d'√©tat** : Nous avons d√©fini un √©tat complet pour suivre tous les aspects du traitement des emails
- **Impl√©mentation de n≈ìuds** : Nous avons cr√©√© des n≈ìuds fonctionnels qui interagissent avec un LLM
- **Routage conditionnel** : Nous avons impl√©ment√© une logique d'embranchement bas√©e sur la classification des emails
- **√âtats terminaux** : Nous avons utilis√© le n≈ìud *END* pour marquer les points d'ach√®vement dans notre *workflow*

## Et maintenant ?

Dans la prochaine section, nous explorerons des fonctionnalit√©s plus avanc√©es de LangGraph, y compris la gestion de l'interaction humaine dans le *workflow* et l'impl√©mentation d'une logique d'embranchement plus complexe bas√©e sur plusieurs conditions.