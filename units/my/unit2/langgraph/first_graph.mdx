# သင်၏ ပထမဆုံး LangGraph ကို တည်ဆောက်ခြင်း

အခုဆိုရင် ကျွန်တော်တို့ဟာ Agent တွေရဲ့ အခြေခံ အစိတ်အပိုင်းတွေကို နားလည်သွားပြီဖြစ်လို့၊ ၎င်းတို့ကို လက်တွေ့ကျတဲ့ လုပ်ငန်းစဉ် (Functional Graph) တစ်ခု တည်ဆောက်ရာမှာ အသုံးချကြည့်ကြပါစို့။ ဒီနေရာမှာ Alfred ရဲ့ Email စီမံခန့်ခွဲမှု စနစ်ကို အကောင်အထည်ဖော်သွားမှာ ဖြစ်ပါတယ်။ Alfred အနေနဲ့ အောက်ပါအဆင့်တွေကို လုပ်ဆောင်ဖို့ လိုအပ်ပါတယ်။

1.  ဝင်လာတဲ့ Email တွေကို ဖတ်ရှုခြင်း။
2.  ၎င်းတို့ကို Spam (အမှိုက်ပုံး) သို့မဟုတ် Legitimate (တရားဝင်) အဖြစ် အမျိုးအစားခွဲခြားခြင်း။
3.  တရားဝင် Email များအတွက် မူကြမ်း တုံ့ပြန်စာ (Preliminary Response) ကို ရေးဆွဲခြင်း။
4.  တရားဝင် Email များအတွက် Mr. Wayne (ဒီနေရာမှာ Mr. Hugg လို့ ပြောင်းသုံးထားပါတယ်) ကို အသိပေးခြင်း (Print ထုတ်ပြသခြင်းသာ)။

ဒီဥပမာက LLM (Large Language Model) ကို အခြေခံတဲ့ ဆုံးဖြတ်ချက်ချမှုများ ပါဝင်တဲ့ Workflow တစ်ခုကို LangGraph နဲ့ ဘယ်လို စနစ်တကျ ဖွဲ့စည်းရမလဲဆိုတာကို ပြသပေးပါလိမ့်မယ်။ ဒီဥပမာမှာ Tool တွေ ပါဝင်ခြင်းမရှိသေးတဲ့အတွက် Agent လို့ အတိအကျ မခေါ်နိုင်သေးပေမယ့်၊ ဒီအပိုင်းက Agent တွေထက် LangGraph Framework ကို လေ့လာဖို့ကို ပိုပြီး အာရုံစိုက်ထားပါတယ်။

> [!TIP]
> ဒီ Code တွေကို <a href="https://huggingface.co/agents-course/notebooks/blob/main/unit2/langgraph/mail_sorting.ipynb" target="_blank">ဒီ Notebook</a> မှာ လိုက်လံကြည့်ရှုနိုင်ပြီး Google Colab ကို အသုံးပြုပြီး ကိုယ်တိုင် Run ကြည့်နိုင်ပါတယ်။

## ကျွန်ုပ်တို့၏ လုပ်ငန်းအဆင့်ဆင့် (Our Workflow)

ကျွန်တော်တို့ တည်ဆောက်မယ့် Workflow ပုံစံက အောက်ပါအတိုင်း ဖြစ်ပါတယ်။

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/first_graph.png" alt="First LangGraph"/>

## အဆင့် ၁: ကျွန်ုပ်တို့၏ State ကို သတ်မှတ်ခြင်း

LangGraph မှာ **State** ဆိုတာဟာ Workflow တစ်လျှောက်လုံးမှာ ခြေရာခံရမယ့် အချက်အလက်တွေ စုစည်းရာ နေရာပဲ ဖြစ်ပါတယ်။ Email စီမံခန့်ခွဲမှု လုပ်ငန်းစဉ်အတွင်း Alfred ခြေရာခံဖို့ လိုအပ်တဲ့ အချက်အလက်တွေကို အောက်ပါအတိုင်း သတ်မှတ်ပါမယ်။

```python
class EmailState(TypedDict):
    # စီမံဆောင်ရွက်နေသော Email
    email: Dict[str, Any]  # Email ၏ ခေါင်းစဉ်၊ ပေးပို့သူ၊ ကိုယ်ထည် စသည်တို့ ပါဝင်သည်။

    # Email ၏ အမျိုးအစား (မေးမြန်းခြင်း၊ တိုင်ကြားခြင်း စသည်)
    email_category: Optional[str]

    # Email ကို Spam အဖြစ် သတ်မှတ်ရသည့် အကြောင်းရင်း
    spam_reason: Optional[str]

    # ခွဲခြမ်းစိတ်ဖြာမှုနှင့် ဆုံးဖြတ်ချက်များ
    is_spam: Optional[bool]
    
    # တုံ့ပြန်စာ မူကြမ်း ရေးဆွဲခြင်း
    email_draft: Optional[str]
    
    # စီမံဆောင်ရွက်မှုဆိုင်ရာ Metadata
    messages: List[Dict[str, Any]]  # LLM နှင့် ဆွေးနွေးမှုများကို ခြေရာခံရန်။
```

> 💡 **အကြံပြုချက်:** သင်၏ State ကို အရေးကြီးသော အချက်အလက်အားလုံးကို ခြေရာခံနိုင်လောက်အောင် ပြည့်စုံအောင် သတ်မှတ်ပါ။ သို့သော် မလိုအပ်သော အသေးစိတ်အချက်အလက်များဖြင့် ရှုပ်ထွေးအောင် မလုပ်ပါနှင့်။

## အဆင့် ၂: ကျွန်ုပ်တို့၏ Node များကို သတ်မှတ်ခြင်း

အခုဆိုရင် ကျွန်တော်တို့ရဲ့ Workflow ကို ဖွဲ့စည်းမယ့် လုပ်ဆောင်ချက် Functions များကို ဖန်တီးကြပါစို့။ LangGraph မှာ ဒီ Functions တွေကို **Nodes** လို့ ခေါ်ပါတယ်။

```python
# ကျွန်ုပ်တို့၏ LLM ကို စတင်အသုံးပြုရန်
model = ChatOpenAI(temperature=0) # temperature=0 သည် LLM ကို ပိုမိုခန့်မှန်းနိုင်သော (Predictable) အဖြေများ ထုတ်ပေးစေရန် သတ်မှတ်ခြင်းဖြစ်သည်။

def read_email(state: EmailState):
    """Alfred သည် ဝင်လာသော Email ကို ဖတ်ရှုပြီး မှတ်တမ်းတင်သည်"""
    email = state["email"]
    
    # ဒီနေရာမှာ အစောပိုင်း ဒေတာ စီမံဆောင်ရွက်မှုအချို့ကို လုပ်ဆောင်နိုင်ပါတယ်။
    print(f"Alfred သည် {email['sender']} ထံမှ {email['subject']} ခေါင်းစဉ်ဖြင့် Email ကို စီမံဆောင်ရွက်နေပါသည်။")
    
    # State ကို ပြောင်းလဲရန် မလိုအပ်ပါ
    return {}

def classify_email(state: EmailState):
    """Alfred သည် Email သည် Spam လား၊ တရားဝင်လားဆိုတာကို LLM ကို အသုံးပြုပြီး ဆုံးဖြတ်သည်"""
    email = state["email"]
    
    # LLM အတွက် Prompt ကို ပြင်ဆင်ခြင်း
    prompt = f"""
    Alfred the butler အနေဖြင့်၊ ဤ Email ကို ခွဲခြမ်းစိတ်ဖြာပြီး Spam လား၊ တရားဝင်လားဆိုတာကို ဆုံးဖြတ်ပါ။
    
    Email:
    From: {email['sender']}
    Subject: {email['subject']}
    Body: {email['body']}
    
    ပထမဦးစွာ၊ ဤ Email သည် Spam ဟုတ်မဟုတ် ဆုံးဖြတ်ပါ။ Spam ဖြစ်ပါက၊ အကြောင်းရင်းကို ရှင်းပြပါ။
    တရားဝင် Email ဖြစ်ပါက၊ ၎င်းကို အမျိုးအစားခွဲခြားပါ (မေးမြန်းခြင်း၊ တိုင်ကြားခြင်း၊ ကျေးဇူးတင်လွှာ စသည်)။
    """
    
    # LLM ကို ခေါ်ဆိုခြင်း
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # ရလဒ်ကို ရိုးရှင်းစွာ စစ်ဆေးခြင်း (လက်တွေ့ Application တွင် ပိုမိုခိုင်မာသော Parsing လိုအပ်သည်)
    response_text = response.content.lower()
    is_spam = "spam" in response_text and "not spam" not in response_text
    
    # Spam ဖြစ်ပါက အကြောင်းရင်းကို ထုတ်ယူခြင်း
    spam_reason = None
    if is_spam and "reason:" in response_text:
        spam_reason = response_text.split("reason:")[1].strip()
    
    # တရားဝင်ပါက အမျိုးအစားကို ဆုံးဖြတ်ခြင်း
    email_category = None
    if not is_spam:
        categories = ["inquiry", "complaint", "thank you", "request", "information"]
        for category in categories:
            if category in response_text:
                email_category = category
                break
    
    # ခြေရာခံရန်အတွက် Messages များကို Update လုပ်ခြင်း
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
    # State အပြောင်းအလဲများကို ပြန်ပို့ခြင်း
    return {
        "is_spam": is_spam,
        "spam_reason": spam_reason,
        "email_category": email_category,
        "messages": new_messages
    }

def handle_spam(state: EmailState):
    """Alfred သည် Spam Email များကို မှတ်စုဖြင့် ဖယ်ရှားသည်"""
    print(f"Alfred သည် Email ကို Spam အဖြစ် သတ်မှတ်လိုက်ပါသည်။ အကြောင်းရင်း: {state['spam_reason']}")
    print("Email ကို Spam Folder သို့ ရွှေ့လိုက်ပါပြီ။")
    
    # ဤ Email စီမံဆောင်ရွက်မှု ပြီးဆုံးပါပြီ
    return {}

def draft_response(state: EmailState):
    """Alfred သည် တရားဝင် Email များအတွက် မူကြမ်း တုံ့ပြန်စာကို ရေးဆွဲသည်"""
    email = state["email"]
    category = state["email_category"] or "general"
    
    # LLM အတွက် Prompt ကို ပြင်ဆင်ခြင်း
    prompt = f"""
    Alfred the butler အနေဖြင့်၊ ဤ Email အတွက် ယဉ်ကျေးသော မူကြမ်း တုံ့ပြန်စာကို ရေးဆွဲပါ။
    
    Email:
    From: {email['sender']}
    Subject: {email['subject']}
    Body: {email['body']}
    
    ဤ Email ကို အမျိုးအစားခွဲခြားထားသည်: {category}
    
    Mr. Hugg မှ ပြန်လည်သုံးသပ်ပြီး ကိုယ်ပိုင်ပြင်ဆင်မှုများ မပြုလုပ်မီ ပေးပို့နိုင်ရန် အတိုချုပ်၊ Professional ဆန်သော တုံ့ပြန်စာကို ရေးဆွဲပါ။
    """
    
    # LLM ကို ခေါ်ဆိုခြင်း
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # ခြေရာခံရန်အတွက် Messages များကို Update လုပ်ခြင်း
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
    # State အပြောင်းအလဲများကို ပြန်ပို့ခြင်း
    return {
        "email_draft": response.content,
        "messages": new_messages
    }

def notify_mr_hugg(state: EmailState):
    """Alfred သည် Mr. Hugg ကို Email အကြောင်း အသိပေးပြီး မူကြမ်း တုံ့ပြန်စာကို ပြသသည်"""
    email = state["email"]
    
    print("\n" + "="*50)
    print(f"သခင်၊ {email['sender']} ထံမှ Email တစ်စောင် လက်ခံရရှိထားပါသည်။")
    print(f"ခေါင်းစဉ်: {email['subject']}")
    print(f"အမျိုးအစား: {state['email_category']}")
    print("\nပြန်လည်သုံးသပ်ရန်အတွက် ကျွန်တော် မူကြမ်း တုံ့ပြန်စာကို ပြင်ဆင်ထားပါတယ်:")
    print("-"*50)
    print(state["email_draft"])
    print("="*50 + "\n")
    
    # ဤ Email စီမံဆောင်ရွက်မှု ပြီးဆုံးပါပြီ
    return {}
```

## အဆင့် ၃: Routing Logic ကို သတ်မှတ်ခြင်း

Email အမျိုးအစားခွဲခြားပြီးနောက် ဘယ်လမ်းကြောင်းကို ဆက်သွားရမလဲဆိုတာကို ဆုံးဖြတ်ဖို့ Function တစ်ခု လိုအပ်ပါတယ်။

```python
def route_email(state: EmailState) -> str:
    """Spam အမျိုးအစားခွဲခြားမှုအပေါ် မူတည်၍ နောက်တစ်ဆင့်ကို ဆုံးဖြတ်သည်"""
    if state["is_spam"]:
        return "spam"
    else:
        return "legitimate"
```

> 💡 **မှတ်ချက်:** ဒီ Routing Function ကို LangGraph က ခေါ်ဆိုပြီး Classification Node ပြီးနောက် ဘယ် Edge (လမ်းကြောင်း) ကို လိုက်ရမလဲဆိုတာကို ဆုံးဖြတ်ပါတယ်။ ပြန်ပို့သော တန်ဖိုးသည် ကျွန်ုပ်တို့၏ Conditional Edges Mapping အတွင်းရှိ Key တစ်ခုနှင့် ကိုက်ညီရပါမယ်။

## အဆင့် ၄: StateGraph ကို ဖန်တီးပြီး Edges များကို သတ်မှတ်ခြင်း

အခုဆိုရင် အရာအားလုံးကို တစ်ခုနှင့်တစ်ခု ချိတ်ဆက်ကြပါစို့။

```python
# Graph ကို ဖန်တီးခြင်း
email_graph = StateGraph(EmailState)

# Nodes များကို ထည့်သွင်းခြင်း
email_graph.add_node("read_email", read_email)
email_graph.add_node("classify_email", classify_email)
email_graph.add_node("handle_spam", handle_spam)
email_graph.add_node("draft_response", draft_response)
email_graph.add_node("notify_mr_hugg", notify_mr_hugg)

# Edges များကို စတင်ခြင်း
email_graph.add_edge(START, "read_email")
# Edges များကို ထည့်သွင်းခြင်း - Flow ကို သတ်မှတ်ခြင်း
email_graph.add_edge("read_email", "classify_email")

# classify_email မှ အခြေအနေအရင်းခံ လမ်းကြောင်းခွဲခြင်းကို ထည့်သွင်းခြင်း
email_graph.add_conditional_edges(
    "classify_email",
    route_email,
    {
        "spam": "handle_spam",
        "legitimate": "draft_response"
    }
)

# နောက်ဆုံး Edges များကို ထည့်သွင်းခြင်း
email_graph.add_edge("handle_spam", END)
email_graph.add_edge("draft_response", "notify_mr_hugg")
email_graph.add_edge("notify_mr_hugg", END)

# Graph ကို Compile လုပ်ခြင်း
compiled_graph = email_graph.compile()
```

LangGraph မှ ပံ့ပိုးပေးသော အထူး `END` Node ကို ကျွန်တော်တို့ အသုံးပြုထားသည်ကို သတိပြုပါ။ ၎င်းသည် Workflow ပြီးဆုံးသွားသော အခြေအနေများကို ဖော်ပြပါတယ်။

## အဆင့် ၅: Application ကို Run ခြင်း

ကျွန်တော်တို့ရဲ့ Graph ကို တရားဝင် Email တစ်စောင်နဲ့ Spam Email တစ်စောင်တို့နဲ့ စမ်းသပ်ကြည့်ကြပါစို့။

```python
# ဥပမာ တရားဝင် Email
legitimate_email = {
    "sender": "john.smith@example.com",
    "subject": "Question about your services",
    "body": "Dear Mr. Hugg, I was referred to you by a colleague and I'm interested in learning more about your consulting services. Could we schedule a call next week? Best regards, John Smith"
}

# ဥပမာ Spam Email
spam_email = {
    "sender": "winner@lottery-intl.com",
    "subject": "YOU HAVE WON $5,000,000!!!",
    "body": "CONGRATULATIONS! You have been selected as the winner of our international lottery! To claim your $5,000,000 prize, please send us your bank details and a processing fee of $100."
}

# တရားဝင် Email ကို စီမံဆောင်ရွက်ခြင်း
print("\nProcessing legitimate email...")
legitimate_result = compiled_graph.invoke({
    "email": legitimate_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "email_draft": None,
    "messages": []
})

# Spam Email ကို စီမံဆောင်ရွက်ခြင်း
print("\nProcessing spam email...")
spam_result = compiled_graph.invoke({
    "email": spam_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "email_draft": None,
    "messages": []
})
```

## အဆင့် ၆: Langfuse ဖြင့် Mail Sorting Agent ကို စစ်ဆေးခြင်း 📡

Alfred သည် Mail Sorting Agent ကို ချိန်ညှိနေစဉ် ၎င်း၏ Run များကို Debug လုပ်ရတာ ပင်ပန်းလာပါတယ်။ Agent များသည် သဘာဝအားဖြင့် ခန့်မှန်းရခက်ပြီး စစ်ဆေးရန် ခက်ခဲပါတယ်။ သို့သော် သူသည် အဆုံးစွန်သော Spam Detection Agent ကို တည်ဆောက်ပြီး Production တွင် အသုံးပြုရန် ရည်ရွယ်ထားသောကြောင့် အနာဂတ် စောင့်ကြည့်မှုနှင့် ခွဲခြမ်းစိတ်ဖြာမှုများအတွက် ခိုင်မာသော ခြေရာခံနိုင်စွမ်း (Traceability) လိုအပ်ပါတယ်။

ဒီလိုလုပ်ဖို့အတွက် Alfred ဟာ Langfuse ကဲ့သို့သော Observability Tool တစ်ခုကို အသုံးပြုပြီး Agent ကို ခြေရာခံ စောင့်ကြည့်နိုင်ပါတယ်။

ပထမဦးစွာ၊ Langfuse ကို Install လုပ်ပါမယ်။
```python
%pip install -q langfuse
```

ဒုတိယအနေဖြင့်၊ Langchain ကို Install လုပ်ပါမယ် (LangFuse ကို အသုံးပြုရန် LangChain လိုအပ်ပါတယ်)။
```python
%pip install langchain
```

ထို့နောက်၊ Langfuse API Key များနှင့် Host Address များကို Environment Variable များအဖြစ် ထည့်သွင်းပါမယ်။ သင်၏ Langfuse Credentials များကို [Langfuse Cloud](https://cloud.langfuse.com) တွင် စာရင်းသွင်းခြင်းဖြင့် ရယူနိုင်ပါတယ်။

```python
import os
 
# Get keys for your project from the project settings page: https://cloud.langfuse.com
os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # 🇪🇺 EU region
# os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # 🇺🇸 US region
```

ပြီးနောက်၊ [Langfuse `callback_handler`](https://langfuse.com/docs/integrations/langchain/tracing#add-langfuse-to-your-langchain-application) ကို Configure လုပ်ပြီး Graph ကို ခေါ်ဆိုရာတွင် `config={"callbacks": [langfuse_handler]}` ကို ထည့်သွင်းခြင်းဖြင့် Agent ကို Instrument လုပ်ပါမယ်။

```python   
from langfuse.langchain import CallbackHandler

# LangGraph/Langchain (tracing) အတွက် Langfuse CallbackHandler ကို စတင်ခြင်း
langfuse_handler = CallbackHandler()

# တရားဝင် Email ကို စီမံဆောင်ရွက်ခြင်း
legitimate_result = compiled_graph.invoke(
    input={"email": legitimate_email, "is_spam": None, "spam_reason": None, "email_category": None, "draft_response": None, "messages": []},
    config={"callbacks": [langfuse_handler]}
)
```

Alfred အခုဆိုရင် ချိတ်ဆက်ပြီးပါပြီ 🔌! LangGraph မှ Run များကို Langfuse တွင် မှတ်တမ်းတင်နေပြီး၊ Agent ၏ အပြုအမူကို အပြည့်အဝ မြင်နိုင်စွမ်း ရရှိသွားပါပြီ။ ဒီ Setup ဖြင့် သူသည် ယခင် Run များကို ပြန်လည်ကြည့်ရှုပြီး Mail Sorting Agent ကို ပိုမိုကောင်းမွန်အောင် ချိန်ညှိနိုင်ပါပြီ။

![Example trace in Langfuse](https://langfuse.com/images/cookbook/huggingface-agent-course/langgraph-trace-legit.png)

_[တရားဝင် Email ဖြင့် Trace ၏ Public Link](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/f5d6d72e-20af-4357-b232-af44c3728a7b?timestamp=2025-03-17T10%3A13%3A28.413Z&observation=6997ba69-043f-4f77-9445-700a033afba1)_

## ကျွန်ုပ်တို့၏ Graph ကို မြင်သာအောင် ပြသခြင်း (Visualizing Our Graph)

LangGraph သည် ကျွန်ုပ်တို့၏ Workflow ကို မြင်သာအောင် ပြသနိုင်ပြီး၊ ၎င်း၏ Structure ကို ပိုမိုနားလည်ရန်နှင့် Debug လုပ်ရန် ကူညီပေးပါတယ်။

```python
compiled_graph.get_graph().draw_mermaid_png()
```
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/mail_flow.png" alt="Mail LangGraph"/>

၎င်းသည် ကျွန်ုပ်တို့၏ Nodes များ မည်သို့ ချိတ်ဆက်ထားပုံနှင့် အခြေအနေအရင်းခံ လမ်းကြောင်းခွဲများ မည်သို့သွားနိုင်ပုံကို ပုံဖြင့် ပြသပေးပါတယ်။

## ကျွန်ုပ်တို့ တည်ဆောက်ခဲ့သည်များ

ကျွန်တော်တို့ဟာ အောက်ပါ လုပ်ဆောင်ချက်များ ပါဝင်တဲ့ ပြည့်စုံတဲ့ Email စီမံဆောင်ရွက်မှု Workflow တစ်ခုကို ဖန်တီးခဲ့ပါတယ်။

1.  ဝင်လာသော Email တစ်စောင်ကို ယူခြင်း။
2.  LLM ကို အသုံးပြုပြီး Spam သို့မဟုတ် တရားဝင်အဖြစ် အမျိုးအစားခွဲခြားခြင်း။
3.  Spam များကို ဖယ်ရှားခြင်းဖြင့် ကိုင်တွယ်ခြင်း။
4.  တရားဝင် Email များအတွက် တုံ့ပြန်စာ မူကြမ်းရေးဆွဲပြီး Mr. Hugg ကို အသိပေးခြင်း။

ဒါဟာ LangGraph ရဲ့ စွမ်းအားကို ပြသပြီး၊ ရှင်းလင်းပြီး စနစ်တကျ ဖွဲ့စည်းထားတဲ့ Flow ကို ထိန်းသိမ်းရင်း LLM များနဲ့ ရှုပ်ထွေးတဲ့ Workflow တွေကို ဘယ်လို စီမံခန့်ခွဲရမလဲဆိုတာကို ပြသပေးပါတယ်။

## အဓိက သင်ခန်းစာများ (Key Takeaways)

*   **State Management:** Email စီမံဆောင်ရွက်မှု၏ အချက်အလက်အားလုံးကို ခြေရာခံရန် ပြည့်စုံသော State ကို သတ်မှတ်ခဲ့ခြင်း။
*   **Node Implementation:** LLM နှင့် အပြန်အလှန် ဆက်သွယ်သော လုပ်ဆောင်ချက် Nodes များကို ဖန်တီးခဲ့ခြင်း။
*   **Conditional Routing:** Email အမျိုးအစားခွဲခြားမှုအပေါ် အခြေခံ၍ လမ်းကြောင်းခွဲခြင်း Logic ကို အကောင်အထည်ဖော်ခဲ့ခြင်း။
*   **Terminal States:** Workflow ပြီးဆုံးသည့် အမှတ်များကို သတ်မှတ်ရန် `END` Node ကို အသုံးပြုခဲ့ခြင်း။

## နောက်ထပ် ဘာတွေ လေ့လာမလဲ?

နောက်အပိုင်းမှာတော့ LangGraph ရဲ့ ပိုမိုအဆင့်မြင့်တဲ့ Features တွေကို လေ့လာသွားပါမယ်။ ၎င်းတို့မှာ Workflow အတွင်း လူသားတို့၏ ပါဝင်မှုကို ကိုင်တွယ်ခြင်းနှင့် အခြေအနေများစွာအပေါ် အခြေခံသော ပိုမိုရှုပ်ထွေးသည့် လမ်းကြောင်းခွဲခြင်း Logic များကို အကောင်အထည်ဖော်ခြင်းတို့ ပါဝင်ပါတယ်။